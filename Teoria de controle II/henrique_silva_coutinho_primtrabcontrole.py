# -*- coding: utf-8 -*-
"""HENRIQUE_SILVA_COUTINHO_PrimTrabControle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vt8UjcDE0ApEuHqv7-0T_N0Lpx5CQ5xM

# Primeiro Trabalho de Teoria de Controle (Turma B) 

$Prof. André Marcato$

A prova deve ser resolvida no próprio Google Colab.

Tirar uma foto ou digitalizar as questões que necessitarem desenvolvimento manual e as insira no próprio google colab através de um bloco de texto.
 
Deixar a prova organizada, ou seja, inserir os blocos de texto ou código após o enunciado das questões.

## Questão 1 

Considere o sistema cuja funçãão de transferêência de malha fechada é:

$ \frac{C(s)}{R(s)} = \frac{10(s+1)}{(s+2)(s+5)}$

Responda o que se pede. *** Valor

a) Faça um programa em um bloco de código em Python para traçar as assíntotas de todos os fatores básicos do $|G(j\omega)|_{db}$.

b) Em um novo bloco de código, some as assíntotas obtidas na letra **a** para obter um gráfico do comportamento assintótico do $|G(j\omega)|_{db}$.

c) Em um novo bloco de código, mostre o gráfico da resposta assintótica e o gráfico da curva exata do $|G(j\omega)|_{db}$ para avaliar os erros originados pela aproximação assintótica.

d) Em um novo bloco de código, faça um novo gráfico com o ângulo de $|G(j\omega)|$ em graus. Obs: Não são os fatores básicos, mas sim apenas o gráfico total do ângulo de $|G(j\omega)|$ em graus.

e) Mostre que a resposta em frequencia em malha fechada desse sistema apresenta um pico de ressonâância, embora o coeficiente de amortecimento dos pólos de malha fechada seja maior que a unidade.

f) Aplicando-se uma entrada $x(t) = 15*sen(0.2t-10^o)$ no sistema em malha fechada qual será a saída $y_{ss}(t)$?

g) Aplicando-se uma entrada $x(t) = 15*sen(3t+30^o)$ no sistema em malha fechada qual será a saída $y_{ss}(t)$?

h) Aplicando-se uma entrada $x(t) = 100*sen(3 \cdot 10^5t+90^o)$ no sistema em malha fechada qual será a saída $y_{ss}(t)$?

## Questão 2

Define-se freqüência de cruzamento de ganho, aquela frequência na qual o gráfico do $|G(j \omega)|_{db}$ cruza o eixo das freqüêências.

Desenvolver um programa em Python para determinar a freqüência de cruzamento de ganho do sistema em falha fechada cuja função de transferência foi especificada no enunciado da ***Questão 1***.

#Questão 1

##**Resolução letra a)**

Passando para a forma padrão temos:
$ \frac{C(s)}{R(s)} = \frac{10(s+1)}{(s+2)(s+5)}=\frac{(1/5)(1/2)10(s+1)}{(1/2)(s+2)(1/5)(s+5)} =\frac{(s+1)}{(\frac{1}{2}s+1)(\frac{1}{5}s+1)}  $

Assim podemos Traçar as assintotas, onde $T_{s2} = \frac{1}{2}$ e $T_{s5} = \frac{1}{5}$.
"""

# !pip install control

# import numpy as np
# from plotly import graph_objects as go
# from plotly.subplots import make_subplots
# from control import *
# from control.matlab import *
# from plotly import graph_objects as go

w=np.logspace(-3,3,1000)


figura = make_subplots(specs=[[{"secondary_y": True}]])

w_baixo2 = w[np.where(w <=2)]
w_alto2 = w[np.where(w > 2)]

gjw_baixo2 = np.zeros(len(w_baixo2), dtype= float)
gjw_alto2 = -20*np.log10(w_alto2*(1/2))
gjw2 = np.concatenate((gjw_baixo2,gjw_alto2))

figura.add_trace(go.Scatter(y=gjw2,x=w,name="Fat. Prim. Ordem Denominador (s+2)"),secondary_y=False)

figura.update_xaxes(type="log")

figura.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="Módulo de $G(j \omega)$ em dB"
)

figura2 = make_subplots(specs=[[{"secondary_y": True}]])

w_baixo5 = w[np.where(w <=5)]
w_alto5 = w[np.where(w > 5)]

gjw_baixo5 = np.zeros(len(w_baixo5), dtype= float)
gjw_alto5 = -20*np.log10(w_alto5*(1/5))
gjw5 = np.concatenate((gjw_baixo5,gjw_alto5))

figura2.add_trace(go.Scatter(y=gjw5,x=w,name="Fat. Prim. Ordem Denominador (s+5)"),secondary_y=False)

figura2.update_xaxes(type="log")

figura2.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="Módulo de $G(j \omega)$ em dB"
)

figura3 = make_subplots(specs=[[{"secondary_y": True}]])

w_baixo1 = w[np.where(w <=1)]
w_alto1 = w[np.where(w > 1)]

gjw_baixo1 = np.zeros(len(w_baixo1), dtype= float)
gjw_alto1 = 20*np.log10(w_alto1)
gjw1 = np.concatenate((gjw_baixo1,gjw_alto1))

figura3.add_trace(go.Scatter(y=gjw1,x=w,name="Fat. Prim. Ordem Numerado (s+1)"),secondary_y=False)

figura3.update_xaxes(type="log")

figura3.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="Módulo de $G(j \omega)$ em dB"
)

"""##**Resolução letra b)**"""

figura4 = make_subplots(specs=[[{"secondary_y": True}]])

gjw = gjw1 + gjw2 + gjw5


figura4.add_trace(go.Scatter(y=gjw,x=w,name="Diagrama de Bode"),secondary_y=False)

figura4.update_xaxes(type="log")

figura4.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="Módulo de $G(j \omega)$ em dB"
)

"""##**Resolução letra c)**"""

# Curva Exata
num = [10, 10]
den = [ 1, 7, 10]
gs = tf(num,den)
diag_bode = bode(gs,w)
gjw_real = diag_bode[0]
gjw_real = 20*np.log10(gjw_real)
figura4.add_trace(go.Scatter(y=gjw_real,x=w,name="Exata"),secondary_y=False)



figura4.update_xaxes(type="log")

figura4.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="Módulo de $G(j \omega)$ em dB"
)

"""##**Resolução letra d)**"""

figura5 = make_subplots(specs=[[{"secondary_y": True}]])

gjw_real = diag_bode[1]
gjw_real = gjw_real*180/np.pi
figura5.add_trace(go.Scatter(y=gjw_real,x=w,name="Exata"),secondary_y=False)



figura5.update_xaxes(type="log")

figura5.update_layout(
    title="Diagrama de Bode",
    xaxis_title="Freqüência em rad/s",
    yaxis_title="ângulo de $G(j \omega)$ em graus"
)

"""##**Resolução letra e)**

Como observado no diagrama de bode, realmente há um pico de ressonancia (2.72, 3,56). Isso se dá pelo fator de primeira ordem no numerador, pois se observarmos a contribuição do zero no modulo da função de transferencia, percebemos que ele provoca um aumento do modulo a partir de w = 1rad/s(se levarmos em consideração á aproximação por assintotas) e as contribuições para a diminuição do módulo dos fatores de primeira ordem do denominador só aparecem em w = 2 rad/s e w = 3 rad/s. Desta forma, o modulo cresce de 1 até 2 rad/s, permanece particamente constante de 2 rad/s até 5 rad/s aonde o polo de ((1/5)s + 1) provoca uma queda do módulo.

##**Resolução letra f)**

Como w = 0.2 rad/s, temos que |g(jw)| tende ao ganho (1) e a defasagem tende 0, logo $Y_{ss} = 15*1+sen(0,2t-10°)$. o que pode ser observado abaixo.
"""

t = np.linspace(0,100,10000)
f = 15*np.sin((0.2)*t - ((10*np.pi)/180))
x0 = 0
saida = lsim(gs, f, t, x0)

figura6 = go.Figure(data=go.Scatter(y=saida[0], x=t))
figura6.add_trace(go.Scatter(y=f, x=t))
figura6.show()

"""##**Resolução letra g)**

Como w = 3 rad/s, temos que olhando no diagrama de bode |g(j3)|= 3,22db, o que convertendo é |g(3j)|=1,504 e a defasagem -15,70°, logo  Yss=22,56+sen(3t+14,30°) . o que pode ser observado abaixo:
"""

t = np.linspace(0,10,10000)
g = 15*np.sin((3)*t + ((30*np.pi)/180))
x0 = 0
saida = lsim(gs, g, t, x0)

figura7 = go.Figure(data=go.Scatter(y=saida[0], x=t))
figura7.add_trace(go.Scatter(y=g, x=t))
figura7.show()

"""##**Resolução letra h)**

Como w = $3*10^5$ rad/s, temos que |g(j3)| tende a 0, pois a frequencia é muito alta, e a defasagem -90°, logo Yss tende a 0. o que pode ser observado abaixo(repare que o valor da escala é muito baixo):
"""

t = np.linspace(0,0.0001,10000)
h = 15*np.sin((300000)*t + ((90*np.pi)/180))
x0 = 0
saida = lsim(gs, h, t, x0)

figura8 = go.Figure(data=go.Scatter(y=saida[0], x=t))
figura8.add_trace(go.Scatter(y=h, x=t))
figura8.show()

"""#Questão 2

Utilizando a função margin, a qual passamos como parametro a função de transferencia, recebemos como retorno alguns valores.  Dentre eles está wp a qual é frequencia pra ganho 1, o que em escala db é 0, ou seja, a frequência a qual o grafico cruza o eixo das frequencias.
"""

sys = tf([10, 10],[1,7,10])
gm, pm, wg, wp = margin(sys)
print (wp)
